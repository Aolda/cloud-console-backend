stages: [check, build, package, image, manifest]

# 공통 기본값 (원하면 생략 가능)
default:
  image: eclipse-temurin:21-jdk
  tags: [acc]
  before_script:
    - export GRADLE_USER_HOME="$CI_PROJECT_DIR/.gradle"
    - chmod +x gradlew

check_runner:
  stage: check
  script:
    - echo "runner OK"; java -version || true

build:
  stage: build
  script:
    - ./gradlew --no-daemon clean build -x test   # ← 테스트 제외
  artifacts:
    when: always
    paths:
      - build/libs/
    expire_in: 7 days

package:
  stage: package
  needs: ["build"]
  script:
    - ./gradlew --no-daemon assemble -x test      # ← 여기서도 제외
  rules:
    - if: $CI_COMMIT_BRANCH == $CI_DEFAULT_BRANCH

# 컨테이너 이미지 빌드(kaniko)
kaniko_build_image:
  stage: image
  image:
    name: gcr.io/kaniko-project/executor:v1.23.2-debug
    entrypoint: [""]
  tags: [acc]
  variables:
    IMAGE_TAG: "$CI_COMMIT_SHORT_SHA"  # 깃랩 커밋 해시(쇼트)
  before_script: []
  script:
    # Docker 인증 정보 작성 (CI_REGISTRY_USER/CI_JOB_TOKEN 사용)
    - |
      mkdir -p /kaniko/.docker
      cat > /kaniko/.docker/config.json <<EOF
      {
        "auths": {
          "https://index.docker.io/v1/": {
            "username": "$DOCKERHUB_USERNAME",
            "password": "$DOCKERHUB_TOKEN"
          }
        }
      }
      EOF
    # 필수 변수 확인: DOCKERHUB_REPO (예: aolda/acc_backend)
    - |
      if [ -z "$DOCKERHUB_REPO" ]; then
        echo "[error] Missing CI variable: DOCKERHUB_REPO (e.g. aolda/acc_backend)" >&2
        exit 1
      fi
    # 캐시를 레지스트리에 저장/활용하여 빠른 빌드
    - >
      /kaniko/executor
      --context "$CI_PROJECT_DIR"
      --dockerfile "$CI_PROJECT_DIR/Dockerfile"
      --destination "docker.io/$DOCKERHUB_REPO:$IMAGE_TAG"
      --cache=true
      --cache-repo "docker.io/$DOCKERHUB_REPO-cache"
  # rules 제거: 모든 파이프라인에서 실행

# 매니페스트의 이미지 태그 갱신 (GitOps 커밋)
update_manifest_image:
  stage: manifest
  image:
    name: alpine:3.19
    entrypoint: [""]
  tags: [acc]
  needs: ["kaniko_build_image"]
  before_script:
    - apk add --no-cache git ca-certificates openssh-client yq
  script: |
    set -euo pipefail
    set -x
    # 필수 변수 확인
    if [ -z "$DOCKERHUB_REPO" ]; then
      echo "[error] Missing CI variable: DOCKERHUB_REPO (e.g. aolda/acc_backend)" >&2; exit 1; fi
    if [ -z "$MANIFEST_FILE" ]; then
      echo "[error] Missing CI variable: MANIFEST_FILE (e.g. acc/backend/acc-backend-deploy.yaml)" >&2; exit 1; fi
    if [ -z "$CONTAINER_NAME" ]; then
      echo "[error] Missing CI variable: CONTAINER_NAME (e.g. acc-backend)" >&2; exit 1; fi
    if [ -z "$GITOPS_REPO_URL" ]; then
      echo "[error] Missing CI variable: GITOPS_REPO_URL (e.g. https://gitlab.com/group/gitops-repo.git)" >&2; exit 1; fi
    if [ -z "$GITOPS_REPO_BRANCH" ]; then
      echo "[error] Missing CI variable: GITOPS_REPO_BRANCH (e.g. main)" >&2; exit 1; fi
    if [ -z "$GITOPS_TOKEN" ]; then
      echo "[error] Missing CI variable: GITOPS_TOKEN (write access token)" >&2; exit 1; fi

    # 새 이미지 태그 구성
    FULL_IMAGE="docker.io/$DOCKERHUB_REPO:$CI_COMMIT_SHORT_SHA"
    export FULL_IMAGE

    # GitOps 레포 클론(HTTPS + Authorization 헤더로 인증)
    GITOPS_USERNAME="${GITOPS_USERNAME:-${GIT_PUSH_USERNAME:-gitlab-ci-token}}"
    AUTH_B64=$(printf "%s:%s" "$GITOPS_USERNAME" "$GITOPS_TOKEN" | base64 | tr -d '\n')
    rm -rf gitops && mkdir -p gitops
    git -c http.extraHeader="Authorization: Basic $AUTH_B64" clone --depth 1 --branch "$GITOPS_REPO_BRANCH" "$GITOPS_REPO_URL" gitops

    # GitOps 레포 내 매니페스트 수정 (단일 파일)
    cd gitops
    yq -i '(.spec.template.spec.containers[] | select(.name == env(CONTAINER_NAME)).image) = env(FULL_IMAGE)' "$MANIFEST_FILE"

    # 변경 사항 커밋 및 푸시 ([skip ci]로 루프 방지)
    git config user.email "ci-bot@${CI_SERVER_HOST}"
    git config user.name "gitlab-ci"
    git add "$MANIFEST_FILE"
    git commit -m "chore: bump image to $FULL_IMAGE [skip ci]" || echo "No changes to commit"
    # 푸시(Authorization 헤더 사용)
    git -c http.extraHeader="Authorization: Basic $AUTH_B64" push origin "$GITOPS_REPO_BRANCH"
